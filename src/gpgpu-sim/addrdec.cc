// Copyright (c) 2009-2011, Wilson W.L. Fung, Tor M. Aamodt, Ali Bakhoda,
// The University of British Columbia
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
// Redistributions in binary form must reproduce the above copyright notice, this
// list of conditions and the following disclaimer in the documentation and/or
// other materials provided with the distribution.
// Neither the name of The University of British Columbia nor the names of its
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#include <string.h>
#include "addrdec.h"
#include "gpu-sim.h"
#include "../option_parser.h"




///////////////////////////////////////////////////////////////////////////////

unsigned part_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1  },
};

unsigned s1_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s3_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 1,  0,  1,  0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{ 1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{ 1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};


unsigned s3_rdm_mtx_24_kain[][24] = {
{1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{1,  1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{1,  0,  1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{0,  1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1  },
{0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

/*
unsigned kain_pae_HBM_mtx_29[][29] = {
 // B  B  B  B  X  X  X  X  X  C  C  C  C  C  
  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0 },
  { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0 },
  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0 },
  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
  //{ 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  //{ 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  //{ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  //{ 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  //{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },

  { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },
 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
};

*/


unsigned kain_pae_HBM_mtx_29[][28] = {
//  B  B  B  B  C  C  C  C  C  X  X  X  X  X  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R
  { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  { 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},  
  { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  
  { 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  
  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   

  { 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   

  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},   
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},  
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},  
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},  
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},  
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},  
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},  
};





unsigned s4_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0  },
{ 0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 1,  0,  1,  0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0  },
{ 1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0  },
{ 1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};


unsigned s1_v3_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  1,  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  1,  0,  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  1,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  },
};


unsigned s3_v3_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  1,  1,  1,  1,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  1,  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  1,  0,  },
{ 1,  0,  1,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  },
{ 0,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  },
{ 1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  1,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  },
};

unsigned overall_v3_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0,  },
{ 0,  0,  1,  1,  1,  1,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  1,  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  1,  0,  },
{ 1,  0,  1,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  0,  1,  0,  },
{ 1,  0,  0,  1,  0,  0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  },
{ 0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1,  1,  0,  1,  0,  0,  },
{ 1,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  },
{ 1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  },
{ 0,  0,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  },
{ 1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  1,  1,  },
{ 1,  0,  0,  1,  0,  1,  0,  1,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  },
{ 0,  1,  0,  1,  0,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  },
{ 0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  },
{ 0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  },
{ 1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0,  },
{ 1,  1,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0,  },
{ 0,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  },
{ 1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  },
{ 0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  },
{ 1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  },
{ 0,  1,  0,  1,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  },
};

///////////////////////////////////////////////////////////////////////////////

unsigned part_v2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1  },
};



unsigned s1_v2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s2_v2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s3_v2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 1,  0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 1,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s4_v2_rdm_mtx_23[][23] = {
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0  },
{ 0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 1,  0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 1,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};


unsigned overall_v2_rdm_mtx_23[][23] = {
{ 0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  },
{ 0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  },
{ 1,  0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  },
{ 1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0,  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0,  },
{ 0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0,  },
{ 1,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1,  },
{ 0,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1,  },
{ 0,  1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1,  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1,  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  },
{ 0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  },
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0,  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  },
{ 1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  },
{ 0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  },
};


unsigned s4_v2_rdm_mtx_25[][25] = {};
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

unsigned part_rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0  },
{ 1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1  },
{ 0,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1  },
{ 1,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  0,  0,  1,  0  },
};

unsigned s1_rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s2_rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};

unsigned s3_rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};


unsigned s4_rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1  },
{ 1,  1,  1,  1,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  1,  0,  1,  1,  0,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
};


unsigned remap_mtx_23[][23] = {
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  }
};

///////////////////////////////////////////////////////////////////////////////

// define different random matrix operator
unsigned rdm_mtx_10[][10] = {
{ 0,  1,  1,  0,  0,  0,  0,  0,  1,  1  },
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 0,  0,  1,  0,  1,  0,  0,  0,  0,  1  },
{ 0,  1,  0,  1,  0,  0,  1,  0,  0,  0  },
{ 1,  1,  0,  0,  0,  1,  0,  0,  1,  1  },
{ 0,  0,  0,  0,  1,  1,  0,  0,  0,  1  },
{ 0,  1,  0,  0,  0,  0,  0,  0,  0,  1  },
{ 1,  1,  0,  0,  0,  0,  0,  0,  0,  0  },
{ 1,  0,  0,  1,  0,  0,  0,  1,  0,  0  }
};

unsigned rdm_mtx_11[][11] = {
{ 0,  1,  0,  1,  1,  0,  1,  1,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  0,  1,  1,  0,  1,  1,  1,  0  },
{ 1,  1,  1,  0,  0,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  1,  1,  0,  0,  0,  1,  0,  1,  1  },
{ 1,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1  },
{ 0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  1  },
{ 1,  1,  0,  0,  1,  1,  0,  1,  1,  1,  1  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  1,  1,  1  }
};

unsigned rdm_mtx_12[][12] = {
{ 0,  0,  0,  0,  1,  1,  0,  1,  0,  1,  1,  0  },
{ 0,  1,  1,  1,  1,  0,  0,  1,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1  },
{ 1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0  },
{ 0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0  },
{ 0,  1,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  1,  1,  0,  1,  0,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  0,  1  },
{ 1,  0,  1,  1,  0,  1,  1,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  1,  0,  1,  1,  0,  1,  0,  1,  1  },
};

unsigned rdm_mtx_13[][13] = {
{ 0,  1,  0,  1,  0,  0,  0,  1,  1,  1,  0,  0,  0  },
{ 1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 0,  0,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 0,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  1  },
{ 1,  1,  1,  1,  0,  0,  0,  1,  1,  1,  0,  1,  0  },
{ 1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  1,  1,  0  },
{ 1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  1,  1,  1  },
{ 1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  1  },
{ 1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0  },
};


unsigned rdm_mtx_14[][14] = {
{ 1,  0,  1,  1,  1,  0,  0,  0,  1,  0,  1,  0,  0,  0  },
{ 1,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1  },
{ 1,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 1,  0,  1,  1,  1,  0,  1,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  0,  0  },
{ 1,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0  },
{ 1,  0,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0  },
{ 0,  0,  0,  0,  1,  0,  1,  0,  1,  1,  0,  1,  1,  1  },
{ 1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  1,  1,  1  },
{ 0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1  },
{ 0,  0,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0  },
};

unsigned rdm_mtx_15[][15] = {
{ 1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  1,  0,  0  },
{ 1,  1,  0,  0,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 1,  0,  0,  0,  1,  1,  0,  0,  0,  1,  1,  0,  0,  1,  1  },
{ 1,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0,  1  },
{ 1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  0,  1,  0  },
{ 1,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1  },
{ 1,  1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  0,  0,  1,  0  },
{ 1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,  1  },
{ 0,  0,  1,  1,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  0  },
{ 1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1  },
{ 1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  1,  1,  0  },
{ 1,  1,  0,  0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0  },
{ 0,  0,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1  },
};

unsigned rdm_mtx_16[][16] = {
{ 1,  1,  0,  0,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1  },
{ 1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0  },
{ 1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0  },
{ 1,  1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0  },
{ 1,  0,  1,  1,  1,  0,  0,  1,  1,  0,  0,  0,  1,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  1  },
{ 1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  1,  1  },
{ 1,  0,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  1  },
{ 1,  1,  1,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0  },
{ 1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  0,  0,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  0,  0,  0  },
{ 1,  0,  1,  0,  1,  0,  0,  1,  0,  0,  1,  1,  0,  1,  1,  1  },
{ 0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  1,  0,  1,  0,  1,  0  },
};

unsigned rdm_mtx_23[][23] = {
{ 0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0,  1,  0  },
{ 0,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1  },
{ 1,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  1,  1  },
{ 1,  0,  0,  0,  1,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  0,  1,  0,  0  },
{ 0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 1,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  0,  0,  0,  1  },
{ 0,  0,  0,  0,  1,  1,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0  },
{ 0,  0,  0,  1,  1,  1,  0,  1,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0,  0,  1,  1  },
{ 0,  0,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1  },
{ 0,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1  },
{ 1,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  0,  1,  0,  0,  1  },
{ 1,  0,  1,  1,  1,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1  },
{ 0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0  },
{ 1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 1,  0,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0  },
{ 1,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  0  },
};

unsigned rdm_mtx_24[][24] = {
{ 1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  1,  1,  1,  0,  0,  0,  1,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  0,  1  },
{ 0,  1,  1,  0,  0,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1  },
{ 1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0  },
{ 1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1  },
{ 0,  1,  0,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  1,  0,  0,  1,  1,  1,  1,  0,  0,  1,  1  },
{ 0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  1  },
{ 1,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1  },
{ 0,  1,  1,  1,  0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  0,  0,  0,  1  },
{ 1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  0,  1  },
{ 1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0  },
{ 1,  1,  1,  1,  0,  0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0  },
{ 1,  0,  1,  0,  1,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1  },
{ 0,  1,  0,  1,  0,  0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  1,  0,  0,  1  },
{ 0,  0,  0,  1,  1,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  0  },
{ 1,  1,  1,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  1,  1,  1,  0,  0,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1  },
{ 1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1  },
{ 1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  0,  1,  0,  1,  1,  1,  1,  0,  1  },
{ 0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1,  1  }
};

unsigned rdm_mtx_25[][25] = {
{ 1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1  },
{ 1,  1,  0,  0,  0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  1,  1,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1  },
{ 0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  1  },
{ 1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  1,  0,  1,  1,  1,  0,  1,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  1,  1,  1,  0,  0,  1  },
{ 1,  1,  1,  1,  0,  0,  1,  0,  0,  1,  1,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0,  1,  0,  1,  1,  0,  1,  1  },
{ 0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0,  1,  0,  0,  1,  0,  1,  1,  1,  0  },
{ 1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  1,  1,  0,  1,  1,  0,  1,  1,  1,  1,  1,  0,  0,  1,  0,  1,  1,  0,  0,  0,  0,  0  },
{ 1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  1  },
{ 0,  0,  0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1  },
{ 1,  1,  0,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  1,  0,  1,  0,  0,  1,  0  },
};

unsigned rdm_mtx_26[][26] = {
{ 1,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  1  },
{ 1,  0,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1  },
{ 1,  0,  0,  0,  1,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  0  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  1  },
{ 1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  0,  1,  1,  0,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  1  },
{ 1,  1,  0,  1,  0,  1,  0,  0,  1,  1,  1,  1,  0,  1,  0,  1,  1,  1,  1,  0,  1,  1,  0,  0,  1,  1  },
{ 1,  0,  1,  1,  0,  1,  1,  0,  1,  1,  0,  0,  0,  1,  0,  1,  0,  0,  1,  0,  1,  0,  0,  1,  1,  1  },
{ 0,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1  },
{ 1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1  },
{ 1,  0,  0,  1,  1,  1,  0,  1,  1,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  0,  0,  0,  0,  0,  1  },
{ 1,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  1,  0,  0,  1,  1,  1,  0,  1,  1,  0,  1,  0,  0  },
{ 0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0  },
{ 1,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  0,  1,  0,  0,  1,  1,  1,  1  },
{ 1,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  1,  0,  1,  0,  1,  1  },
{ 1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1,  0,  0,  1,  0,  0,  1  },
{ 0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1,  1,  1,  0,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1  },
{ 0,  1,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  0,  1,  0,  1,  1,  1,  1,  1,  0,  1,  0,  0,  1  },
{ 0,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  0  },
{ 0,  1,  1,  0,  1,  0,  1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  1  },
{ 1,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  1,  0,  0,  1,  1,  0,  0,  1,  0,  1,  0,  0,  1  },
{ 1,  0,  0,  0,  1,  0,  0,  0,  1,  0,  1,  1,  0,  0,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0  },
{ 1,  0,  1,  0,  1,  0,  1,  0,  0,  0,  0,  1,  1,  1,  1,  1,  0,  1,  0,  1,  0,  1,  1,  1,  1,  0  },
{ 0,  1,  0,  0,  1,  1,  0,  1,  0,  0,  0,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  0,  0,  1,  0,  1  },
{ 0,  0,  1,  1,  0,  1,  0,  1,  0,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1  },
{ 1,  0,  1,  0,  1,  1,  0,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  1,  1,  1,  0,  0,  1,  0,  1  },
{ 0,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  0,  1,  1,  1,  1,  0,  1  },
};















// added by yuxi, 3d dm part
static new_addr_type get_rightmost_bit(unsigned k, new_addr_type mask);

static long int powli( long int x, long int y );
static unsigned int LOGB2_32( unsigned int v );
static new_addr_type addrdec_packbits( new_addr_type mask, new_addr_type val, unsigned char high, unsigned char low);
static void addrdec_getmasklimit(new_addr_type mask, unsigned char *high, unsigned char *low); 

linear_to_raw_address_translation::linear_to_raw_address_translation()
{
   addrdec_option = NULL;
   ADDR_CHIP_S = 10;
   memset(addrdec_mklow,0,N_ADDRDEC);
   memset(addrdec_mkhigh,64,N_ADDRDEC);
   // changed by freeman, 3d part
   // addrdec_mask[0] = 0x0000000000001C00;
   // addrdec_mask[1] = 0x0000000000000300;
   // addrdec_mask[2] = 0x000000000FFF0000;
   // addrdec_mask[3] = 0x000000000000E0FF;
   // addrdec_mask[4] = 0x000000000000000F;
   
   // 3d part
   // initialization
   addrdec_mask[0] = 0x0000000000001C00; // chip
   addrdec_mask[1] = 0x0000000000001C00; // vault
   addrdec_mask[2] = 0x0000000000001C00; // layer
   addrdec_mask[3] = 0x0000000000000300; // bank
   addrdec_mask[4] = 0x000000000FFF0000; // row
   addrdec_mask[5] = 0x000000000000E0FF; // column
   addrdec_mask[6] = 0x000000000000000F; // burst
}

void linear_to_raw_address_translation::addrdec_setoption(option_parser_t opp)
{
   option_parser_register(opp, "-gpgpu_mem_addr_mapping", OPT_CSTR, &addrdec_option,
      "mapping memory address to dram model {dramid@<start bit>;<memory address map>}",
      NULL);
   option_parser_register(opp, "-gpgpu_mem_addr_test", OPT_BOOL, &run_test,
      "run sweep test to check address mapping for aliased address",
      "0");
   option_parser_register(opp, "-gpgpu_mem_address_mask", OPT_INT32, &gpgpu_mem_address_mask, 
               "0 = old addressing mask, 1 = new addressing mask, 2 = new add. mask + flipped bank sel and chip sel bits",
               "0");

   // added by yuxi, 3d dm part
   option_parser_register(opp, "-gpgpu_xor_mapping_enabled", OPT_BOOL, &xor_mapping_enabled,
      "enable xor mapping for address space",
      "0");
   option_parser_register(opp, "-gpgpu_xor_upper_bit_start", OPT_UINT32, &xor_upper_bit_start,
      "the number of shifting bits for xor mapping (to form higher-order bits)",
      "0");

   option_parser_register(opp, "-gpgpu_random_mapping_enabled", OPT_BOOL, &random_mapping_enabled,
      "enable random mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_pre_part_random_mapping_enabled", OPT_BOOL, &pre_part_random_mapping_enabled,
      "enable random mapping for address space, only parallelism-favored bits are randomized including column index; row index bits are kicked out",
      "0");

   //////////////////////////////////////////////
   option_parser_register(opp, "-gpgpu_part_random_mapping_enabled", OPT_BOOL, &part_random_mapping_enabled,
      "enable random mapping for address space;"
      "12 row bits are overall randomized"
      "channel+bank bits are randomized using channel+bank+row space"
      "5 column bits are not utilized in order to maintain row buffer locality",
      "0");


   option_parser_register(opp, "-gpgpu_s1_random_mapping_enabled", OPT_BOOL, &s1_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_s2_random_mapping_enabled", OPT_BOOL, &s2_random_mapping_enabled,
      "our solution mapping for address space",
      "0");


   option_parser_register(opp, "-gpgpu_s3_random_mapping_enabled", OPT_BOOL, &s3_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

      s3_random_mapping_enabled = 1;

   option_parser_register(opp, "-gpgpu_s4_random_mapping_enabled", OPT_BOOL, &s4_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_part_v2_random_mapping_enabled", OPT_BOOL, &part_v2_random_mapping_enabled,
      "enable random mapping for address space;"
      "12 row bits are overall randomized"
      "channel+bank bits are randomized using channel+bank+row space"
      "5 column bits are not utilized in order to maintain row buffer locality",
      "0");

   option_parser_register(opp, "-gpgpu_s1_v2_random_mapping_enabled", OPT_BOOL, &s1_v2_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_s2_v2_random_mapping_enabled", OPT_BOOL, &s2_v2_random_mapping_enabled,
      "our solution mapping for address space",
      "0");


   option_parser_register(opp, "-gpgpu_s3_v2_random_mapping_enabled", OPT_BOOL, &s3_v2_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_s4_v2_random_mapping_enabled", OPT_BOOL, &s4_v2_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_overall_v2_random_mapping_enabled", OPT_BOOL, &overall_v2_random_mapping_enabled,
      "enable random mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_s1_v3_random_mapping_enabled", OPT_BOOL, &s1_v3_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_s3_v3_random_mapping_enabled", OPT_BOOL, &s3_v3_random_mapping_enabled,
      "our solution mapping for address space",
      "0");

   option_parser_register(opp, "-gpgpu_overall_v3_random_mapping_enabled", OPT_BOOL, &overall_v3_random_mapping_enabled,
      "enable random mapping for address space",
      "0");
   


   //////////////////////////////////////////////

   option_parser_register(opp, "-gpgpu_la2pa_mapping_enabled", OPT_BOOL, &la2pa_mapping_enabled,
      "enable la2pa mapping for address space",
      "0");
   option_parser_register(opp, "-gpgpu_most_para_bit", OPT_UINT32, &gpgpu_most_para_bit,
      "most parallel bit",
      "0");
   option_parser_register(opp, "-gpgpu_la2pa_mask", OPT_CSTR, &la2pa_mask_option,
      "mapping linear address to physica address {la2pa memory address mask}",
      NULL);

   // remap matrix
   option_parser_register(opp, "-gpgpu_remap_matrix_enabled", OPT_BOOL, &remap_mtx_mapping_enabled,
      "enable remap mapping matrix for address space",
      "0");

   option_parser_register(opp, "-gpgpu_remap_matrix", OPT_CSTR, &remap_matrix_option,
      "remap matrix options (default is PPPPPPPPPPPLLLLLLLLLLLL)",
      NULL);
}

// added by yuxi, 3d dm part
unsigned linear_to_raw_address_translation::xor_upper_bit(unsigned base, new_addr_type val) const
{
   unsigned nchipbits = ::LOGB2_32(m_n_channel);
   unsigned pos = 0;
   unsigned upper_xor = 0;
   for(unsigned i=0; i<nchipbits; i++) {
      unsigned xor_bit = i + xor_upper_bit_start;
      upper_xor |= (( val & ((unsigned long long int)1<< xor_bit  ) ) >> xor_bit) << pos;
      pos++;
   }

   return upper_xor ^ base;
}

void linear_to_raw_address_translation::remap_mtx_init()
{
   mtx_init();
   generate_remap_matrix();

   remap_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   assert( num_bits == 23 );

   for( unsigned i=0; i<num_bits; i++ ) {
      remap_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( remap_mtx_23[i][j] == 1 )
                remap_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("remap_mtx[%u] is 0x%llx\n", i, remap_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::generate_remap_matrix()
{
   // remap matrix part
   printf("remap_matrix_option is %s\n", remap_matrix_option);
   assert( strlen(remap_matrix_option) == 23 );

   // set 11 parallel bits
   for( unsigned x=0; x<11; x++ ) {
      for( unsigned y=0; y<23; y++ ) {
         if( remap_matrix_option[y] == 'P' ) {
             remap_mtx_23[x][y] = 1;
             remap_matrix_option[y] = 'p';
             break;
         }
      }
   }

   // set 12 parallel bits
   for( unsigned x=22; x>10; x-- ) {
      for( unsigned y=22; y>0; y-- ) {
         if( remap_matrix_option[y] == 'L' ) {
             remap_mtx_23[x][y] = 1;
             remap_matrix_option[y] = 'l';
             break;
         }
      }
   }

   printf("remap matrix is:\n");
   for ( unsigned i=0; i<23; i++ ) {
      for ( unsigned j=0; j<23; j++ ) {
          printf("%u ", remap_mtx_23[i][j]);
      }
      printf("\n");
   }

   printf("remap_matrix_option is %s\n", remap_matrix_option);
}

new_addr_type linear_to_raw_address_translation::addrdec_remap_mtx_tlx(new_addr_type raw_addr) const
{
   new_addr_type remap_addr = 0;

   // cache line bits
   for( unsigned i=0; i<num_cache_line_bits; i++) {
       new_addr_type pos = (1ULL) << i;
       remap_addr |= ( raw_addr & pos );
   }

   // highest bits
   for( unsigned i=num_tot_bits; i<MAX_ADDR_BIT; i++) {
       new_addr_type pos = (1ULL) << i;
       remap_addr |= ( raw_addr & pos );
   }

   unsigned tot_bits = num_parallel_bits + num_local_bits;
   new_addr_type mask = parallel_mask | local_mask;

   for( unsigned i=0; i<tot_bits; i++) {
      new_addr_type cur = 0;
      for( unsigned j=0; j<tot_bits; j++) {
         unsigned k = get_rightmost_bit( j, mask );
         new_addr_type pos = (1ULL) << k;
         new_addr_type left  = ( (raw_addr & pos) >> k );
         new_addr_type right = ( (remap_mtx_opr[i] & pos) >> k );
         cur ^= ( left & right );
      }

      remap_addr |= ( cur << get_rightmost_bit(i, mask) );
   }


   // printf("raw 0x%llx to remap_mtx 0x%llx\n", raw_addr, remap_addr);

   return remap_addr;
}

// added by yuxi, 3d dm m6 part
unsigned linear_to_raw_address_translation::xor_lower_upper_bit(new_addr_type val) const
{
   // m_n_channel is not power of 2
   assert(gap != 0);

   unsigned nchipbits = ::LOGB2_32(m_n_channel) + 1;
   unsigned pos = 0;
   unsigned lower_xor = 0;
   unsigned upper_xor = 0;

   // get lower_xor
   for(unsigned i=0; i<nchipbits; i++) {
      unsigned xor_bit = i + ADDR_CHIP_S;
      lower_xor |= (( val & ((unsigned long long int)1<< xor_bit  ) ) >> xor_bit) << pos;
      pos++;
   }

   // get upper_xor
   pos = 0;
   for(unsigned i=0; i<nchipbits; i++) {
      unsigned xor_bit = i + xor_upper_bit_start;
      upper_xor |= (( val & ((unsigned long long int)1<< xor_bit  ) ) >> xor_bit) << pos;
      pos++;
   }

   return (upper_xor ^ lower_xor) % m_n_channel ;
}

std::map<new_addr_type, new_addr_type*> KAIN_page_table;
new_addr_type linear_to_raw_address_translation::partition_address( new_addr_type p_addr ) const 
{ 
   // added by yuxi, 3d dm part
   new_addr_type addr = get_raw_addr(p_addr);


   {
        std::map<new_addr_type,  new_addr_type*> ::iterator iter = KAIN_page_table.find(addr&0xfffe00000);
        if(iter == KAIN_page_table.end()) //insert the new address
        {
            assert(0);// it is impossible to reach here in this function call
        }
        else
            //addr = iter->second[0] | (addr & 0x00000001fffff);
            addr = ((((iter->second[0]>> 23) << 2) | ((addr & 0x00000001fffff) >> 19)) << 21) | 
            ((addr & 0x000000007ffff) | (((iter->second[0]>> 21)&0x0000003)<<19));
   }



   if (!gap) {
      return addrdec_packbits( ~(addrdec_mask[CHIP] | sub_partition_id_mask), addr, 64, 0 ); 
   } else {
      // see addrdec_tlx for explanation 
      unsigned long long int partition_addr; 
      partition_addr = ( (addr>>ADDR_CHIP_S) / m_n_channel) << ADDR_CHIP_S; 
      partition_addr |= addr & ((1 << ADDR_CHIP_S) - 1); 
      // remove the part of address that constributes to the sub partition ID
      partition_addr = addrdec_packbits( ~sub_partition_id_mask, partition_addr, 64, 0); 
      return partition_addr; 
   }
}

unsigned linear_to_raw_address_translation::get_num_bits_per_dram_unit(new_addr_type addr)
{
    unsigned num_bits = 0;
    while(addr) {
        addr &= (addr - 1);
        num_bits++;
    }
    return num_bits;
}

// added by yuxi, 3d dm part
new_addr_type linear_to_raw_address_translation::addrdec_la2pa_tlx(new_addr_type raw_addr) const
{
   new_addr_type la2pa_addr = 0;

   new_addr_type most_para_bit = ( ( raw_addr & ((1ULL)<< gpgpu_most_para_bit) ) >> gpgpu_most_para_bit );
   for( unsigned i=0; i<64; i++) {
      new_addr_type pos = (1ULL) << i;
      if( la2pa_mask & pos ) {
         la2pa_addr |=  ( (( raw_addr & pos ) >> i) ^ most_para_bit) << i;
      
      } else {
         la2pa_addr |= ( raw_addr & pos );
      
      }
   
   }

   // if( most_para_bit == (new_addr_type)0 ) {
   //    printf("most_para_bit %u 0x%llx la 0x%llx to pa 0x%llx\n", gpgpu_most_para_bit, most_para_bit, raw_addr, la2pa_addr);
   // }
   return la2pa_addr;
}

///////////////////////////////////////
// matrix initialization

void linear_to_raw_address_translation::mtx_init()
{
   local_mask = 0;
   parallel_mask = 0;

   local_mask |= addrdec_mask[ROW];
   parallel_mask |= addrdec_mask[CHIP];
   parallel_mask |= addrdec_mask[VAULT];
   parallel_mask |= addrdec_mask[LAYER];
   parallel_mask |= addrdec_mask[BK];
   parallel_mask |= addrdec_mask[COL];

   // set all cache line bits as 0
   num_cache_line_bits = 7;
   for( unsigned i=0; i<num_cache_line_bits; i++) {
      new_addr_type pos = (1ULL) << i;
      parallel_mask &= (~pos);
      local_mask    &= (~pos);
   }

   num_local_bits = get_num_bits_per_dram_unit(local_mask);
   num_parallel_bits = get_num_bits_per_dram_unit(parallel_mask);
   num_tot_bits = num_cache_line_bits + num_local_bits + num_parallel_bits;

   printf("local 0x%llx num_local_bits %u para 0x%llx num_parallel_bits %u \n", local_mask, num_local_bits, parallel_mask, num_parallel_bits);

}

void linear_to_raw_address_translation::rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;
   if( random_mapping_enabled && !pre_part_random_mapping_enabled ) {
      num_bits = num_parallel_bits + num_local_bits;
      // adde num_bits == 25 for hmc_rdm
      assert( num_bits == 23 || num_bits == 25 );

      for( unsigned i=0; i<num_bits; i++ ) {
         rdm_mtx_opr[i] = 0;
         for( unsigned j=0; j<num_bits; j++ ) {
            if( num_bits == 23 ) {
                if( rdm_mtx_23[i][j] == 1 )
                   rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
            } else if( num_bits == 25 ) {
                if( rdm_mtx_25[i][j] == 1 )
                   rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
            } else assert(0);
         }
      }
   } else if ( random_mapping_enabled && pre_part_random_mapping_enabled ) {
      num_bits = num_parallel_bits;

      // because cache_line_bits (7) > burst_bits (6), so the 6th bits may be parallel_bit or locality_bit
      // for 3d-stacked memory, num_parallel_bits is 15 or higher
      assert( num_bits == 11 || num_bits == 12 || num_bits == 15 || num_bits == 16 );

      for( unsigned i=0; i<num_bits; i++ ) {
         rdm_mtx_opr[i] = 0;

         for( unsigned j=0; j<num_bits; j++ ) {
            if( num_bits == 11 ) {
               if( rdm_mtx_11[i][j] == 1 ) {
                  rdm_mtx_opr[i] |= (1ULL) << get_rightmost_bit(j, parallel_mask);
               }
            } else if( num_bits == 12 ) {
               if( rdm_mtx_12[i][j] == 1 ) {
                  rdm_mtx_opr[i] |= (1ULL) << get_rightmost_bit(j, parallel_mask);
               }
            } else if( num_bits == 15 ) {
               if( rdm_mtx_15[i][j] == 1 ) {
                  rdm_mtx_opr[i] |= (1ULL) << get_rightmost_bit(j, parallel_mask);
               }
            } else if( num_bits == 16 ) {
               if( rdm_mtx_16[i][j] == 1 ) {
                  rdm_mtx_opr[i] |= (1ULL) << get_rightmost_bit(j, parallel_mask);
               }
            } else assert(0);
         }
      }
   } else
       assert(0);


   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::part_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( part_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( part_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("part_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}
void linear_to_raw_address_translation::s1_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s1_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( s1_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s1_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( s2_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s3_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm//kain 29->HBM
   assert( num_bits == 23 || num_bits == 25 || num_bits == 24 || num_bits == 28);

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s3_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( s3_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 24 ) {
             if( s3_rdm_mtx_24_kain[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 28 ) {
             if( kain_pae_HBM_mtx_29[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         }
         else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s3_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s4_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s4_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( s4_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s4_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::part_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( part_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("part_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::s1_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s1_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s1_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::s1_v3_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s1_v3_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s1_v3_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s2_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s2_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s2_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::s3_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s3_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s3_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

void linear_to_raw_address_translation::overall_v3_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( overall_v3_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("overall_v3_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::overall_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( overall_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("overall_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s3_v3_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s3_v3_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s3_v3_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}


void linear_to_raw_address_translation::s4_v2_rdm_init()
{
   mtx_init();
   rdm_mtx_opr = new new_addr_type[MAX_ADDR_BIT];

   // if num_bits == 25, 26 etc, add codes here
   unsigned num_bits = 0;

   num_bits = num_parallel_bits + num_local_bits;
   // adde num_bits == 25 for hmc_rdm
   assert( num_bits == 23 || num_bits == 25 );

   for( unsigned i=0; i<num_bits; i++ ) {
      rdm_mtx_opr[i] = 0;
      for( unsigned j=0; j<num_bits; j++ ) {
         if( num_bits == 23 ) {
             if( s4_v2_rdm_mtx_23[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else if( num_bits == 25 ) {
             if( s4_v2_rdm_mtx_25[i][j] == 1 )
                rdm_mtx_opr[i] |= (1ULL) <<  get_rightmost_bit(j, parallel_mask | local_mask);
         } else assert(0);
      }
   }

   printf("\n");
   for( unsigned i=0; i<num_bits; i++ ) {
      printf("s4_v2_rdm_mtx[%u] is 0x%llx\n", i, rdm_mtx_opr[i]);
   }
   printf("\n");
}

///////////////////////////////////////
// address translation


new_addr_type linear_to_raw_address_translation::addrdec_random_tlx(new_addr_type raw_addr) const
{
   new_addr_type rdm_addr = 0;

   // cache line bits
   for( unsigned i=0; i<num_cache_line_bits; i++) {
       new_addr_type pos = (1ULL) << i;
       rdm_addr |= ( raw_addr & pos );
   }

   // highest bits
   for( unsigned i=num_tot_bits; i<MAX_ADDR_BIT; i++) {
       new_addr_type pos = (1ULL) << i;
       rdm_addr |= ( raw_addr & pos );
   }

   unsigned tot_bits = num_parallel_bits + num_local_bits;
   new_addr_type mask = parallel_mask | local_mask;

   for( unsigned i=0; i<tot_bits; i++) {
      new_addr_type cur = 0;
      for( unsigned j=0; j<tot_bits; j++) {
         unsigned k = get_rightmost_bit( j, mask );
         new_addr_type pos = (1ULL) << k;
         new_addr_type left  = ( (raw_addr & pos) >> k );
         new_addr_type right = ( (rdm_mtx_opr[i] & pos) >> k );
         cur ^= ( left & right );
      }

      rdm_addr |= ( cur << get_rightmost_bit(i, mask) );
   }

   // printf("raw 0x%llx to rdm 0x%llx\n", raw_addr, rdm_addr);

   return rdm_addr;
}

new_addr_type linear_to_raw_address_translation::addrdec_part_random_tlx(new_addr_type raw_addr) const
{
   new_addr_type rdm_addr = 0;

   // cache line bits
   for( unsigned i=0; i<num_cache_line_bits; i++) {
       new_addr_type pos = (1ULL) << i;
       rdm_addr |= ( raw_addr & pos );
   }

   // row bits
   rdm_addr |= ( raw_addr & local_mask );

   // highest bits
   for( unsigned i=num_tot_bits; i<MAX_ADDR_BIT; i++) {
       new_addr_type pos = (1ULL) << i;
       rdm_addr |= ( raw_addr & pos );
   }

   // printf("before rdm, raw 0x%llx to rdm 0x%llx\n", raw_addr, rdm_addr);

   unsigned tot_bits = num_parallel_bits;
   new_addr_type mask = parallel_mask;

   for( unsigned i=0; i<tot_bits; i++) {
      new_addr_type cur = 0;
      for( unsigned j=0; j<tot_bits; j++) {
         unsigned k = get_rightmost_bit(j, mask);
         new_addr_type pos = (1ULL) << k;
         new_addr_type left  = ( (raw_addr & pos) >> k );
         new_addr_type right = ( (rdm_mtx_opr[i] & pos) >> k );
         cur ^= ( left & right );
      }

      rdm_addr |= ( cur << get_rightmost_bit(i, mask) );
   }

   // printf("raw 0x%llx to rdm 0x%llx\n", raw_addr, rdm_addr);

   return rdm_addr;
}

unsigned long long kain = 0;
// translate the original address to raw address
new_addr_type linear_to_raw_address_translation::get_raw_addr(new_addr_type addr) const
{
//    addr &= 0x00010000;//KAIN
   new_addr_type raw_addr = addr;
   if( la2pa_mapping_enabled )
      raw_addr = addrdec_la2pa_tlx(addr);
   else if (random_mapping_enabled) {
      if( pre_part_random_mapping_enabled )
         raw_addr = addrdec_part_random_tlx(addr);
      else
         raw_addr = addrdec_random_tlx(addr);
   } else if ( 
           s1_random_mapping_enabled || 
           s2_random_mapping_enabled || 
           s3_random_mapping_enabled || 
           s4_random_mapping_enabled || 
           s1_v2_random_mapping_enabled || 
           s2_v2_random_mapping_enabled || 
           s3_v2_random_mapping_enabled || 
           s4_v2_random_mapping_enabled || 
           part_random_mapping_enabled ||
           part_v2_random_mapping_enabled ||
           s1_v3_random_mapping_enabled || 
           s3_v3_random_mapping_enabled || 
           overall_v2_random_mapping_enabled ||
           overall_v3_random_mapping_enabled
           ) {
       raw_addr = addrdec_random_tlx(addr);
   } else if ( remap_mtx_mapping_enabled ) {
       raw_addr = addrdec_remap_mtx_tlx(addr);
       raw_addr = addrdec_random_tlx(addr);
   }

   // unsigned long long slice_id = (kain++)%32;
   //return raw_addr & 0xffff07ff | (slice_id << 11);

   return raw_addr;
}


new_addr_type linear_to_raw_address_translation::kain_addrdec_tlx(new_addr_type p_addr, mem_fetch *mf) const
{
    new_addr_type addr = get_raw_addr(p_addr);


   {
        std::map<new_addr_type,  new_addr_type*> ::iterator iter = KAIN_page_table.find(addr&0xfffe00000);
        if(iter == KAIN_page_table.end()) //insert the new address
        {
            assert(0);//it should not come here
        }
        else
            //addr = iter->second[0] | (addr & 0x00000001fffff);
            addr = ((((iter->second[0] >> 23) << 2) | ((addr & 0x00000001fffff) >> 19)) << 21) | 
            ((addr & 0x000000007ffff) | (((iter->second[0] >> 21)&0x0000003)<<19));
   }





    new_addr_type kain_bank_addr = (addr >> 7)& 0x000f;
    new_addr_type kain_column_addr = (addr >> 11) & 0x001f;
    new_addr_type kain_row_addr = (addr >> 21) & 0x7fff;


//    kain_bank_addr = 0;
//    kain_row_addr = kain++;
  //  kain_column_addr = 0;


    new_addr_type kain_result = (kain_column_addr<<7) | (kain_bank_addr<<12) | (kain_row_addr<<16);

    //kain_result = 0x7fffffff;
    //printf("KAIN OLD %0x, New %0x, bank_addr %0x, column_addr %0x, row addr %0x, New New %0x\n", p_addr, addr, kain_bank_addr,kain_column_addr,kain_row_addr, kain_result);
    return kain_result;
}

std::vector<new_addr_type *> kain_page_cycle[2];
long long kain_page_count[2];
long long kain_memory_page_create_count[4];
extern std::set <unsigned long long> KAIN_page_addr[4];
// p_addr is original linear address
void linear_to_raw_address_translation::addrdec_tlx(new_addr_type p_addr, addrdec_t *tlx,mem_fetch * mf, unsigned tpc) const
{  
   // added by yuxi, 3d dm part
   new_addr_type addr = get_raw_addr(p_addr);
   mf->kain_cycle = addr;

   unsigned tpc_real = tpc;

   {
        std::map<new_addr_type,  new_addr_type*> ::iterator iter = KAIN_page_table.find(addr&0xfffe00000);
        if(iter == KAIN_page_table.end()) //insert the new address
        {
            //printf("First time come here, addr %0x\n",addr&0xfffffc000);
            //assert(tpc<128);//here we assume at most 80 SMs and 20/40 SMs per chiplet
            //new_addr_type addr_v = (((addr & 0xfffe00000)>>19)+(tpc/64)*2 + kain_page_count[tpc/64]%2) << 21;
            int chiplet_id = 0; 

            if(KAIN_page_addr[0].find(addr&0xfffe00000) != KAIN_page_addr[0].end())
                chiplet_id = 0; 
            else if(KAIN_page_addr[1].find(addr&0xfffe00000) != KAIN_page_addr[1].end())
                chiplet_id = 1; 
            else if(KAIN_page_addr[2].find(addr&0xfffe00000) != KAIN_page_addr[2].end())
                chiplet_id = 2; 
            else if(KAIN_page_addr[3].find(addr&0xfffe00000) != KAIN_page_addr[3].end())
                chiplet_id = 3; 
            else
            {
                printf("addr %0x not find\n", addr&0xfffe00000); 
                chiplet_id = (kain_memory_page_create_count[0]+kain_memory_page_create_count[1]+kain_memory_page_create_count[2]+kain_memory_page_create_count[3])%4;
                assert(0);
            }


            long long kain_page_count_per_stack = kain_memory_page_create_count[chiplet_id];
            new_addr_type addr_v =  ((kain_page_count_per_stack<<2)+(chiplet_id))  << 21;//here we have 32 channels, man
            unsigned long long *kain_tmp = (unsigned long long *)malloc(sizeof(unsigned long long) *2);
            kain_tmp[0] = addr_v;
            if(mf->get_access_type() == GLOBAL_ACC_R || mf->get_access_type() == GLOBAL_ACC_W)
            {
                unsigned long long sum = 0;
                for(int i = 0; i < kain_page_cycle[tpc/64].size(); i++)
                {
                    unsigned long long *tmp= kain_page_cycle[tpc/64][i];
                    if (sum < (*tmp))
                        sum = *tmp;
                }
                    
                kain_tmp[1] = 0;// assume the gloabl memory is not loaded, incurs the page fault
                kain_page_cycle[tpc/64].push_back(kain_tmp+1);// this part decreases in the gpgpu-sim::cycle()
                printf("new page Mem stack %d, page id %0x, previous sum %lld\n", (tpc/32), addr_v&0xfffe00000, sum);

                kain_memory_page_create_count[chiplet_id]++;
            }
            else
                kain_tmp[1] = 0;



            KAIN_page_table.insert(std::pair<new_addr_type, new_addr_type*>(addr&0xfffe00000, kain_tmp));
         //   addr = addr_v | (addr & 0x00000001fffff);

            addr = ((((addr_v >> 23) << 2) | ((addr & 0x00000001fffff) >> 19)) << 21) | 
            ((addr & 0x000000007ffff) | (((addr_v >> 21)&0x0000003)<<19));
        }
        else
        {
            //printf("Sceond time come here, addr %0x\n", addr&0xfffffc000);
            //addr = (iter->second)[0] | (addr & 0x00000001fffff);
            addr = ((((iter->second[0] >> 23) << 2) | ((addr & 0x00000001fffff) >> 19)) << 21) | 
            ((addr & 0x000000007ffff) | (((iter->second[0] >> 21)&0x0000003)<<19));

            /*
            if(mf->get_access_type() == INST_ACC_R)//We assume the instruction memory are replicated to the near memory stack
            {
                new_addr_type addr_v = (iter->second)[0];
                addr = ((((addr_v & 0xfffe00000)>>19)+(tpc/32)) << 21) | (addr & 0x00000001fffff);
            }
            */
            //printf("mf type %d, cycle is %lld\n", mf->get_access_type(), mf->kain_cycle);
        }
   }

   mf->kain_cycle2 = addr;

   //printf("KAIN input %0x, output %0x, Thanks! Yuxi\n",p_addr, addr);
//   fflush(stdout);

   unsigned long long int addr_for_chip,rest_of_addr;
   if (!gap) {
      // namely gap == 0, 3d part
      // number of chip is power of two: 
      tlx->chip = addrdec_packbits(addrdec_mask[CHIP], addr, addrdec_mkhigh[CHIP], addrdec_mklow[CHIP]);

      // added by yuxi, 3d dm part
      if( xor_mapping_enabled ) {
          tlx->chip = xor_upper_bit(tlx->chip, addr);
      }

      tlx->vault = addrdec_packbits(addrdec_mask[VAULT], addr, addrdec_mkhigh[VAULT], addrdec_mklow[VAULT]);
      tlx->layer = addrdec_packbits(addrdec_mask[LAYER], addr, addrdec_mkhigh[LAYER], addrdec_mklow[LAYER]);
      tlx->bk   = addrdec_packbits(addrdec_mask[BK], addr, addrdec_mkhigh[BK], addrdec_mklow[BK]);
      tlx->row  = addrdec_packbits(addrdec_mask[ROW], addr, addrdec_mkhigh[ROW], addrdec_mklow[ROW]);
      tlx->col  = addrdec_packbits(addrdec_mask[COL], addr, addrdec_mkhigh[COL], addrdec_mklow[COL]);
      tlx->burst= addrdec_packbits(addrdec_mask[BURST], addr, addrdec_mkhigh[BURST], addrdec_mklow[BURST]);
   } else {
      // added by yuxi, 3d dm m6 part
      // the following has been verified now
      // Split the given address at ADDR_CHIP_S into (MSBs,LSBs)
      // - extract chip address using modulus of MSBs
      // - recreate the rest of the address by stitching the quotient of MSBs and the LSBs 
      addr_for_chip = (addr>>ADDR_CHIP_S) % m_n_channel; 
      rest_of_addr = ( (addr>>ADDR_CHIP_S) / m_n_channel) << ADDR_CHIP_S; 
      rest_of_addr |= addr & ((1 << ADDR_CHIP_S) - 1); 

      tlx->chip = addr_for_chip; 

      // added by yuxi, 3d dm m6 part
      if( xor_mapping_enabled ) {
          tlx->chip = xor_lower_upper_bit(addr);
      }

      tlx->bk   = addrdec_packbits(addrdec_mask[BK], rest_of_addr, addrdec_mkhigh[BK], addrdec_mklow[BK]);
      // the following has not been tested, 3d part
      tlx->vault   = addrdec_packbits(addrdec_mask[VAULT], rest_of_addr, addrdec_mkhigh[VAULT], addrdec_mklow[VAULT]);
      tlx->layer   = addrdec_packbits(addrdec_mask[LAYER], rest_of_addr, addrdec_mkhigh[LAYER], addrdec_mklow[LAYER]);
      tlx->row  = addrdec_packbits(addrdec_mask[ROW], rest_of_addr, addrdec_mkhigh[ROW], addrdec_mklow[ROW]);
      tlx->col  = addrdec_packbits(addrdec_mask[COL], rest_of_addr, addrdec_mkhigh[COL], addrdec_mklow[COL]);
      tlx->burst= addrdec_packbits(addrdec_mask[BURST], rest_of_addr, addrdec_mkhigh[BURST], addrdec_mklow[BURST]);
   }

   // combine the chip address and the lower bits of DRAM bank address to form the subpartition ID
   unsigned sub_partition_addr_mask = m_n_sub_partition_in_channel - 1; 
   tlx->sub_partition = tlx->chip * m_n_sub_partition_in_channel
                        + ((tlx->bk)& sub_partition_addr_mask); 
                       // + ((tlx->bk ^ (tlx->vault>>2))& sub_partition_addr_mask); 


    {
    //    assert(m_n_sub_partition_in_channel == 8);
        int MCs_ID = tlx->chip;

        //printf("KAIN tpc %d, bk id %d\n",tpc, tlx->bk);

        tlx->sub_partition = tpc_real/32*16+
                         //((tlx->bk)& 0x1f);; //SM0-20 use MC0 LLC slices, SM21-40 use MC1 LLC slices....
                         ((tlx->bk)& 0xf); //in l2cache.cc, also needs to modify the mapping

        //printf("ZSQ: tlx->sub_partition = tpc_real/32*16+((tlx->bk)& 0xf) = %u /32*16 + (%u & 0xf)= %u\n", tpc_real, tlx->bk, tpc_real/32*16+((tlx->bk)& 0xf));
       // tlx->sub_partition = tpc/64*32+tpc%32;

//        printf("addr before %0x, addr after %0x, col %0x\n", p_addr, addr, tlx->col);
        //fflush(stdout);
    }
    
    //printf("ZSQ: chip = %u, sub_partition = %u\n", tlx->chip, tlx->sub_partition);
    fflush(stdout);

}

void linear_to_raw_address_translation::addrdec_la2pa_option(const char *option)
{
   const char *cmapping = option;
   la2pa_mask = 0x0;

   int ofs = 63;
   while ((*cmapping) != '\0') {
      switch (*cmapping) {
         case 'T': case 't':   la2pa_mask |= (1ULL << ofs); ofs--; break;
         // ignore bit
         case '0': ofs--; break;
         // ignore character
         case '|':
         case ' ':
         case '.': break;
         default:
            fprintf(stderr, "ERROR: Invalid la2pa address mapping character '%c' in option '%s'\n", *cmapping, option);
      }
      cmapping += 1;
   }

   if (ofs != -1) {
      fprintf(stderr, "ERROR: Invalid la2pa address mapping length (%d) in option '%s'\n", 63 - ofs, option);
      assert(ofs == -1);
   }
}

void linear_to_raw_address_translation::addrdec_parseoption(const char *option)
{
   unsigned int dramid_start = 0;
   int dramid_parsed = sscanf(option, "dramid@%d", &dramid_start);
   if (dramid_parsed == 1) {
      ADDR_CHIP_S = dramid_start;
   } else {
      ADDR_CHIP_S = -1;
   }
   
   const char *cmapping = strchr(option, ';');
   if (cmapping == NULL) {
      cmapping = option;
   } else {
      cmapping += 1;
   }

   addrdec_mask[CHIP] = 0x0;
   addrdec_mask[VAULT] = 0x0; // 3d part
   addrdec_mask[LAYER] = 0x0;
   addrdec_mask[BK]   = 0x0;
   addrdec_mask[ROW]  = 0x0;
   addrdec_mask[COL]  = 0x0;
   addrdec_mask[BURST]= 0x0;
   
   int ofs = 63;
   while ((*cmapping) != '\0') {
      switch (*cmapping) {
         case 'D': case 'd':  
            assert(dramid_parsed != 1); addrdec_mask[CHIP]  |= (1ULL << ofs); ofs--; break;
         case 'B': case 'b':   addrdec_mask[BK]    |= (1ULL << ofs); ofs--; break;
         case 'V': case 'v':   addrdec_mask[VAULT]   |= (1ULL << ofs); ofs--; break; // 3d part
         case 'L': case 'l':   addrdec_mask[LAYER]   |= (1ULL << ofs); ofs--; break;
         case 'R': case 'r':   addrdec_mask[ROW]   |= (1ULL << ofs); ofs--; break;
         case 'C': case 'c':   addrdec_mask[COL]   |= (1ULL << ofs); ofs--; break;
         // changed by yuxi, 3d dm part
         // originally BURST bits are included in COL bits
         // case 'S': case 's':   addrdec_mask[BURST] |= (1ULL << ofs); ofs--; break;
         case 'S': case 's':   addrdec_mask[BURST] |= (1ULL << ofs); addrdec_mask[COL]   |= (1ULL << ofs); ofs--; break;
         // ignore bit
         case '0': ofs--; break;
         // ignore character
         case '|':
         case ' ':
         case '.': break;
         default:
            fprintf(stderr, "ERROR: Invalid address mapping character '%c' in option '%s'\n", *cmapping, option);
      }
      cmapping += 1;
   }

   if (ofs != -1) {
      fprintf(stderr, "ERROR: Invalid address mapping length (%d) in option '%s'\n", 63 - ofs, option);
      assert(ofs == -1);
   }
}

void linear_to_raw_address_translation::init(unsigned int n_channel, unsigned int n_sub_partition_in_channel) 
{
   unsigned i;
   unsigned long long int mask;
   unsigned int nchipbits = ::LOGB2_32(n_channel);
   m_n_channel = n_channel;
   m_n_sub_partition_in_channel = n_sub_partition_in_channel; 

   gap = (n_channel - ::powli(2,nchipbits));
   if (gap) {
      nchipbits++;
   }
   switch (gpgpu_mem_address_mask) {
   case 0: 
      //old, added 2row bits, use #define ADDR_CHIP_S 10
      ADDR_CHIP_S = 10;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000000300;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x0000000000001CFF;
      break;
   case 1:
      ADDR_CHIP_S = 13;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 2:
      ADDR_CHIP_S = 11;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 3:
      ADDR_CHIP_S = 11;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x000000000FFFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;

   case 14:
      ADDR_CHIP_S = 14;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 15:
      ADDR_CHIP_S = 15;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 16:
      ADDR_CHIP_S = 16;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 6:
      ADDR_CHIP_S = 6;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 5:
      ADDR_CHIP_S = 5;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;                         
   case 100:
      ADDR_CHIP_S = 1;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000000003;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x0000000000001FFC;
      break;
   case 103:
      ADDR_CHIP_S = 3;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000000003;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x0000000000001FFC;
      break;
   case 106:
      ADDR_CHIP_S = 6;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000001800;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x00000000000007FF;
      break;
   case 160: 
      //old, added 2row bits, use #define ADDR_CHIP_S 10
      ADDR_CHIP_S = 6;
      addrdec_mask[CHIP] = 0x0000000000000000;
      addrdec_mask[VAULT]  = 0x0000000000000000; // fake, 3d part
      addrdec_mask[LAYER]  = 0x0000000000000000;
      addrdec_mask[BK]   = 0x0000000000000300;
      addrdec_mask[ROW]  = 0x0000000007FFE000;
      addrdec_mask[COL]  = 0x0000000000001CFF;

   default:
      break;
   }

   if (addrdec_option != NULL) 
      addrdec_parseoption(addrdec_option);

   // added by yuxi, 3d dm part
   if (la2pa_mask_option != NULL) 
      addrdec_la2pa_option(la2pa_mask_option);

   if (ADDR_CHIP_S != -1) { 
      if (!gap) {
         // namely gap == 0, 3d part
         // number of chip is power of two: 
         // - insert CHIP mask starting at the bit position ADDR_CHIP_S
         mask = ((unsigned long long int)1 << ADDR_CHIP_S) - 1;
         addrdec_mask[VAULT]   = ((addrdec_mask[VAULT] & ~mask) << nchipbits) | (addrdec_mask[VAULT] & mask);
         addrdec_mask[LAYER]  = ((addrdec_mask[LAYER] & ~mask) << nchipbits) | (addrdec_mask[LAYER] & mask);
         addrdec_mask[BK]   = ((addrdec_mask[BK] & ~mask) << nchipbits) | (addrdec_mask[BK] & mask);
         addrdec_mask[ROW]  = ((addrdec_mask[ROW] & ~mask) << nchipbits) | (addrdec_mask[ROW] & mask);
         addrdec_mask[COL]  = ((addrdec_mask[COL] & ~mask) << nchipbits) | (addrdec_mask[COL] & mask);

         for (i=ADDR_CHIP_S;i<(ADDR_CHIP_S+nchipbits);i++) {
            mask = (unsigned long long int)1 << i;
            addrdec_mask[CHIP] |= mask;
         }
      } // otherwise, no need to change the masks
   } else {
      // make sure n_channel is power of two when explicit dram id mask is used
      assert((n_channel & (n_channel - 1)) == 0); 
   }
   // make sure m_n_sub_partition_in_channel is power of two 
   assert((m_n_sub_partition_in_channel & (m_n_sub_partition_in_channel - 1)) == 0); 

   addrdec_getmasklimit(addrdec_mask[CHIP],  &addrdec_mkhigh[CHIP],  &addrdec_mklow[CHIP] );
   addrdec_getmasklimit(addrdec_mask[VAULT],  &addrdec_mkhigh[VAULT],  &addrdec_mklow[VAULT] );
   addrdec_getmasklimit(addrdec_mask[LAYER],  &addrdec_mkhigh[LAYER],  &addrdec_mklow[LAYER] );
   addrdec_getmasklimit(addrdec_mask[BK],    &addrdec_mkhigh[BK],    &addrdec_mklow[BK]   );
   addrdec_getmasklimit(addrdec_mask[ROW],   &addrdec_mkhigh[ROW],   &addrdec_mklow[ROW]  );
   addrdec_getmasklimit(addrdec_mask[COL],   &addrdec_mkhigh[COL],   &addrdec_mklow[COL]  );
   addrdec_getmasklimit(addrdec_mask[BURST], &addrdec_mkhigh[BURST], &addrdec_mklow[BURST]);

   // added by yuxi, 3d part
   printf("mapping is %s\n", addrdec_option);

   printf("addr_dec_mask[CHIP]  = %016llx \thigh:%d low:%d\n", addrdec_mask[CHIP],  addrdec_mkhigh[CHIP],  addrdec_mklow[CHIP] );
   printf("addr_dec_mask[VAULT]   = %016llx \thigh:%d low:%d\n", addrdec_mask[VAULT],   addrdec_mkhigh[VAULT],   addrdec_mklow[VAULT] );
   printf("addr_dec_mask[LAYER]   = %016llx \thigh:%d low:%d\n", addrdec_mask[LAYER],   addrdec_mkhigh[LAYER],   addrdec_mklow[LAYER] );
   printf("addr_dec_mask[BK]    = %016llx \thigh:%d low:%d\n", addrdec_mask[BK],    addrdec_mkhigh[BK],    addrdec_mklow[BK]   );
   printf("addr_dec_mask[ROW]   = %016llx \thigh:%d low:%d\n", addrdec_mask[ROW],   addrdec_mkhigh[ROW],   addrdec_mklow[ROW]  );
   printf("addr_dec_mask[COL]   = %016llx \thigh:%d low:%d\n", addrdec_mask[COL],   addrdec_mkhigh[COL],   addrdec_mklow[COL]  );
   printf("addr_dec_mask[BURST] = %016llx \thigh:%d low:%d\n", addrdec_mask[BURST], addrdec_mkhigh[BURST], addrdec_mklow[BURST]);

   if( random_mapping_enabled )
      rdm_init();

   if( part_random_mapping_enabled )
      part_rdm_init();

   if( s1_random_mapping_enabled )
      s1_rdm_init();

   if( s2_random_mapping_enabled )
      s2_rdm_init();

   if( s3_random_mapping_enabled )
      s3_rdm_init();

   if( s4_random_mapping_enabled )
      s4_rdm_init();

   if( part_v2_random_mapping_enabled )
      part_v2_rdm_init();

   if( s1_v2_random_mapping_enabled )
      s1_v2_rdm_init();

   if( s2_v2_random_mapping_enabled )
      s2_v2_rdm_init();

   if( s4_v2_random_mapping_enabled )
      s4_v2_rdm_init();

   if( s1_v3_random_mapping_enabled )
      s1_v3_rdm_init();

   if( s3_v3_random_mapping_enabled )
      s3_v3_rdm_init();

   if( overall_v2_random_mapping_enabled )
      overall_v2_rdm_init();

   if( overall_v3_random_mapping_enabled )
      overall_v3_rdm_init();


   if( remap_mtx_mapping_enabled ) {
      remap_mtx_init();
      s2_rdm_init();
   }

   // create the sub partition ID mask (for removing the sub partition ID from the partition address)
   sub_partition_id_mask = 0; 
   if (m_n_sub_partition_in_channel > 1) {
      unsigned n_sub_partition_log2 = LOGB2_32(m_n_sub_partition_in_channel); 
      unsigned pos=0;
      for (unsigned i=addrdec_mklow[BK];i<addrdec_mkhigh[BK];i++) {
         if ((addrdec_mask[BK] & ((unsigned long long int)1<<i)) != 0) {
            sub_partition_id_mask |= ((unsigned long long int)1<<i);
            pos++;
            if (pos >= n_sub_partition_log2) 
               break; 
         }
      }
   }
   printf("sub_partition_id_mask = %016llx\n", sub_partition_id_mask);

   if (run_test) {
      sweep_test(); 
   }
}

#include "../tr1_hash_map.h" 

bool operator==(const addrdec_t &x, const addrdec_t &y) 
{
   return ( memcmp(&x, &y, sizeof(addrdec_t)) == 0 ); 
}

bool operator<(const addrdec_t &x, const addrdec_t &y) 
{
   if (x.chip >= y.chip) return false; 
   else if (x.vault >= y.vault) return false; 
   else if (x.layer>= y.layer) return false; 
   else if (x.bk >= y.bk) return false;
   else if (x.row >= y.row) return false;
   else if (x.col >= y.col) return false;
   else if (x.burst >= y.burst) return false;
   else return true; 
}

class hash_addrdec_t
{
public: 
   size_t operator()(const addrdec_t &x) const {
      return (x.chip ^ x.vault ^ x.layer ^ x.bk ^ x.row ^ x.col ^ x.burst); 
   }
};

// a simple sweep test to ensure that two linear addresses are not mapped to the same raw address 
void linear_to_raw_address_translation::sweep_test() const
{
   new_addr_type sweep_range = 16 * 1024 * 1024; 

#if tr1_hash_map_ismap == 1
   typedef tr1_hash_map<addrdec_t, new_addr_type> history_map_t; 
#else
   typedef tr1_hash_map<addrdec_t, new_addr_type, hash_addrdec_t> history_map_t; 
#endif
   history_map_t history_map; 

   for (new_addr_type raw_addr = 4; raw_addr < sweep_range; raw_addr += 4) {
      addrdec_t tlx; 
      assert(0);
      addrdec_tlx(raw_addr, &tlx,0,0); 

      history_map_t::iterator h = history_map.find(tlx); 

      if (h != history_map.end()) {
         printf("[AddrDec] ** Error: address decoding mapping aliases two addresses to same partition with same intra-partition address: %llx %llx\n", h->second, raw_addr); 
         abort(); 
      } else {
         assert((int)tlx.chip < m_n_channel); 
         // ensure that partition_address() returns the concatenated address 
         if ((ADDR_CHIP_S != -1 and raw_addr >= (1ULL << ADDR_CHIP_S)) or 
             (ADDR_CHIP_S == -1 and raw_addr >= (1ULL << addrdec_mklow[CHIP]))) {
            assert(raw_addr != partition_address(raw_addr)); 
         }
         history_map[tlx] = raw_addr; 
      }

      if ((raw_addr & 0xffff) == 0) printf("%llu scaned\n", raw_addr); 
   }
}

void addrdec_t::print( FILE *fp ) const
{
   fprintf(fp,"\tchip:%x ", chip);
   fprintf(fp,"\tvault:%x ", vault);
   fprintf(fp,"\tlayer:%x ", layer);
   fprintf(fp,"\trow:%x ", row);
   fprintf(fp,"\tcol:%x ", col);
   fprintf(fp,"\tbk:%x ", bk);
   fprintf(fp,"\tburst:%x ", burst);
   fprintf(fp,"\tsub_partition:%x ", sub_partition);
} 


static long int powli( long int x, long int y ) // compute x to the y
{
   long int r = 1;
   int i; 
   for (i = 0; i < y; ++i ) {
      r *= x;
   }
   return r;
}

static unsigned int LOGB2_32( unsigned int v ) 
{
   unsigned int shift;
   unsigned int r;

   r = 0;

   shift = (( v & 0xFFFF0000) != 0 ) << 4; v >>= shift; r |= shift;
   shift = (( v & 0xFF00    ) != 0 ) << 3; v >>= shift; r |= shift;
   shift = (( v & 0xF0      ) != 0 ) << 2; v >>= shift; r |= shift;
   shift = (( v & 0xC       ) != 0 ) << 1; v >>= shift; r |= shift;
   shift = (( v & 0x2       ) != 0 ) << 0; v >>= shift; r |= shift;

   return r;
}

static new_addr_type addrdec_packbits( new_addr_type mask, new_addr_type val, unsigned char high, unsigned char low) 
{
   unsigned pos=0;
   new_addr_type result = 0;
   for (unsigned i=low;i<high;i++) {
      if ((mask & ((unsigned long long int)1<<i)) != 0) {
         result |= ((val & ((unsigned long long int)1<<i)) >> i) << pos;
         pos++;
      }
   }
   return result;
}

static void addrdec_getmasklimit(new_addr_type mask, unsigned char *high, unsigned char *low) 
{
   *high = 64;
   *low = 0;
   int i;
   int low_found = 0;

   for (i=0;i<64;i++) {
      if ((mask & ((unsigned long long int)1<<i)) != 0) {
         if (low_found) {
            *high = i + 1;
         } else {
            *high = i + 1;
            *low = i;
            low_found = 1;
         }
      }
   }
}



// added by yuxi, 3d dm part
static new_addr_type get_rightmost_bit(unsigned k, new_addr_type mask)
{
   while( k > 0 ) {
      mask &= (mask - 1);
      k--;
   }

   return LOGB2_32( mask ^ (mask & (mask-1)) );
}

